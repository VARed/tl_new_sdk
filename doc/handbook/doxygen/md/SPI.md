@page SPI_Example SPI


# Introduction

## Standard SPI interface

The Serial Peripheral Interface (SPI) is a synchronous serial peripheral interface that allows embedded processors to communicate and exchange data with various peripheral devices in a serial manner.

The standard SPI interface typically uses four lines of communication:

![SPI Interface](pic/spiinterface.png "SPI Interface")

|Name|Meaning|
|:---------|-------------------------------------|
|CSN|Device chip select signal line, active low|
|CLK|Clock signal line|
|MOSI|Master data output and Slave data input line|
|MISO|Master data input and Slave data output line|

## SPI communication process

The following figure shows a simple example of SPI communication:

![SPI communication](pic/spicommunication.png "SPI communication")

This is the communication timing of a standard SPI. The CSN, CLK, and MOSI signals are generated by the Master, and the data output is through the MOSI line, while the MISO signal is generated by the Slave, and the Master reads the data from the Slave through this signal line. The MOSI and MISO signals are only active when CSN is low. The sampling is triggered at the rising or falling edge of CLK. In each clock cycle of CLK, MOSI and MISO transfer 1bit data, and can achieve 1byte data transfer in 8 clock cycles.

According to the different CLK Clock Polarity (CPOL) at idle time and CLK Clock Phase (CPHA) at sampling time, SPI distinguishes four working modes as the following table, the host and slave need to work in the same mode to communicate properly.

|SPI working mode|CPOL|CPHA|
|:----------:|:-------:|:-------:|
|SPI_MODE0|0|0|
|SPI_MODE1|0|1|
|SPI_MODE2|1|0|
|SPI_MODE4|1|1|

CPOL: Clock Polarity

- When CPOL = 0, CLK is held low at idle time.
- When CPOL=1, CLK is held high at idle time.

CPHA: Clock Phase

- When CPHA = 0, sampling is triggered at the odd edge of CLK.
- When CPHA = 1, sampling is triggered at the even edge of CLK.

## Diversified SPI interface

On the basis of the standard SPI, many types of SPI interfaces have gradually been derived to suit different application scenarios.

3line SPI: 3line SPI implies only 3 lines as the name, CLK, CSN, and MOSI. The data sending and receiving share a common line, which is half-duplex communication.

Dual SPI: it extends the usage of MOSI and MISO by making them work in half-duplex and transferring data in the same direction to double the data transfer. That is, for Dual SPI, MOSI becomes IO0 and MISO becomes IO1, so that 2 bits of data can be transferred in one clock cycle, doubling the data transfer.

Quad SPI: similar to Dual SPI, it extends the usage of WP and HOLD, WP becomes IO2 and HOLD becomes IO3. Which means, it has four data lines at the same time and can transfer 4 bits in one clock cycle, the transfer speed is significantly increased.

![Diversified SPI interface](pic/diversifiedspiinterface.png "Diversified SPI interface")

# Function description

The SOC contains a variety of SPI modules, including HSPI, SPI and SPI Slave, each with appropriate driver support.

## Interface description

The interface naming rule is as follows.

- spi as prefix: an interface that can be used by both hspi and pspi.
- pspi as prefix: for pspi use only.
- hspi as prefix: for hspi use only.
- dma as suffix: the interface that will be used by dma mode.
- plus as suffix: support richer read/write modes and operation commands.

For example, the spi_master_write_read_dma_plus interface will use the DMA channel when in use, first writing the address to the SPI Slave and then reading the data from the corresponding address of the SPI Slave.

**Note:**

> - The function of the interfaces with the "read" or "write_read" segment is to read data from the SPI Slave.
> - The difference between the above two is as below:
        (1) The interface with the "read" segment supports hardware auto-sending address frames for applications that enable hardware address frame, and the interface can directly read data from the corresponding address.
        (2) The interface with the "write_read" segment is used without enabling the hardware address frame. The address information is first written to the SPI Slave by "write" and then the data at the corresponding address can be read.

## HSPI and PSPI

HSPI and PSPI are two advanced SPI interfaces supported by the SoC, both supporting Master and Slave modes. HSPI/PSPI Slave both automatically parse cmd and require software operation for data receiving and sending.

**Note:**

> - In the example, the HSPI/PSPI Slave receives and sends data through software, which has the advantage of being more flexible in configuration and supporting Quad I/O mode, but has the disadvantage of not being as easy to configure as using the SPI Slave module directly and consuming computing resources. If you need to simply configure the device as a Slave, it is recommended to use the SPI Slave module.

### Master

**Standard SPI Master**

The HSPI/PSPI module of the SoC supports the standard SPI Master mode, in which the function interface is called without the "plus" suffix and the functions and modes are relatively simple.

Initialize the interface as follows:

```C
spi_master_config(SPI_MODULE_SEL, SPI_NOMAL);
```

The supported interfaces for read and write operations are:

```C
void spi_master_write(spi_sel_e spi_sel, u8 *data, u32 len);
void spi_master_write_dma(spi_sel_e spi_sel, u8 * data, u32 len);
void spi_master_write_read(spi_sel_e spi_sel, u8 * addr , u32 addr_len, u8 * data , u32 data_len);
void spi_master_write_read_dma(spi_sel_e spi_sel, u8 *addr, u32 addr_len, u8 *data, u32 data_len);
```

**HSPI/PSPI Master**

Function description:

The SoC's HSPI/PSPI Master has additional hardware configurations for several frame information in common protocols, including cmd frame, address frame, and dummy frame (null cycle).

In the table below, among the features supported by HSPI/PSPI Master, Y stands for supported and N stands for not supported.

----------------------------------------------------------------------------------
 SPI Module   cmd_en   cmd_fmt   address_en   address_fmt   3line    Dual    Quad
------------ -------- --------- ------------ ------------- -------- ------- ------
   HSPI         Y        Y         Y            Y             Y        Y       Y

   PSPI         Y        N         N            N             Y        Y       N

----------------------------------------------------------------------------------

- cmd_en: hardware cmd frame
- cmd_fmt: cmd frame follows the encoding format corresponding to Dual/Quad I/O
- address_en: hardware address frame
- address_fmt: cmd frame follows the encoding format corresponding to Dual/Quad I/O
- 3line: 3line SPI mode
- Dual: Dual SPI mode
- Quad: Quad SPI mode

Data frame format:

HSPI/PSPI Master supports sending data in the following format: [cmd] + [adress] + [dummy] + data. [] stands for optional.

Step 1 The data frame format supported by the HSPI is configured by calling the following structure interface, and the PSPI is similar:

```C
hspi_config_st hspi_slave_protocol_config = {
    .hspi_io_mode = HSPI_QUAD,
    .hspi_ dummy _cnt = 6,
    .hspi_ cmd _en = 1,
    .hspi_addr_en = 1 ,
    .hspi_addr_len = 3,//when hspi_addr_en = false,invalid set.
    .hspi_cmd_fmt_en = 0,//when hspi_cmd_en = false,invalid set.
    .hspi_addr_fmt_en = 1 ,//when hspi_addr_en = false,invalid set.
};
```

This code configures the various frame parameters of the HSPI Master:

- Module is configured as Quad I/O mode
- dummy frame length is 6 clocks.
- Hardware cmd is enabled, cmd transmission is in Single I/O mode, not following the encoding format corresponding to Dual/Quad I/O (hspi_cmd_fmt_en = 0).
- Hardware address is enabled, with the address frame length of 3 Bytes, following the encoding format corresponding to Dual/Quad I/O (hspi_addr_fmt_en = 1).

The corresponding communication timing diagram is as follows:

![Communication Timing](pic/communicationtiming.png "Communication Timing")

Call the following interface to enable the configuration of the frame parameters:

```C
hspi_master_config_plus(&hspi_slave_protocol_config);
```

Interface for read/write operation calls:

The interface for HSPI/PSPI Master read/write operation calls is as follows:

```C
void spi_master_write_plus(spi_sel_e spi_sel, u8 cmd, u32 addr, u8 *data, u32 data_len, spi_wr_tans_mode_e wr_mode); 
void spi_master_write_dma_plus(spi_sel_e spi_sel, u8 cmd, u32 addr, u8 *data, u32 data_len, spi_wr_tans_mode_e wr_mode);

void spi_master_read_plus(spi_sel_e spi_sel, u8 cmd, u32 addr, u8 *data, u32 data_len, spi_rd_tans_mode_e rd_mode);
void spi_master_read_dma_plus(spi_sel_e spi_sel, u8 cmd, u32 addr, u8 *dst_addr, u32 data_len, spi_rd_tans_mode_e rd_mode);

void spi_master_write_read_plus(spi_sel_e spi_sel, u8 cmd, u8 *addrs, u32 addr_len, u8 *data, u32 data_len, spi_rd_tans_mode_e wr_ mode);
void spi_master_write_read_dma_plus(spi_sel_e spi_sel, u8 cmd, u8 *addr, u32 addr_len, u8 *rd_data, u32 rd_len, spi_rd_tans_mode_e rd_mode);
```

Read and write method:

The HSPI/PSPI Master operates the SPI Slave through the operation commands and also needs to configure the HSPI/PSPI read/write method to match the operation process. The read/write method is used to indicate whether the operation requires a dummy (empty cycle) frame and whether the command operation is a read or a write.

The enumeration for the read-write method is defined as follows:

```C
typedef enum{
    SPI_MODE_WR_WRITE_ONLY = 1,//write
    SPI_MODE_WR_DUMMY_WRITE = 8,//dummy_write
}spi_wr_tans_mode_e;

typedef enum{
    SPI_MODE_RD_READ_ONLY = 2,//must enbale CmdEn
    SPI_MODE_RD_DUMMY_READ = 9,//dummy_read
}spi_rd_tans_mode_e;

typedef enum{
    SPI_MODE_WR_RD       = 3,//must enbale CmdEn
    SPI_MODE_WR_DUMMY_RD = 5,//write_dummy_read
}spi_wr_rd_tans_mode_e; .
```

For example, when reading data, SPI Slave requires to have dummy idle frame, and SPI_MODE_RD_DUMMY_READ method should be selected for reading data.

### Slave

The SoC's HSPI supports Single, Dual, and Quad I/O modes when used as a Slave. The PSPI supports Single and Dual I/O modes when used as a Slave. Both of them automatically parse cmd, but Slave data receiving and sending requires software operation.

**Communication data frame format**

The communication data frame formats supported by HSPI/PSPI Slave are listed in the table below.

(1) HSPI/PSPI SINGLE WRITE

|MOSI_IO0|cmd (write 8bit)|dummy (8clock)|data0|...|
|---|:---:|:---:|:---:|:---:|
|MISO_IO1|-|-|-|-|

(2) HSPI/PSPI SINGLE READ

|MOSI_IO0|cmd (read 8bit)|dummy (8clock)|-|...|
|---|:---:|:---:|:---:|:---:|
|MISO_IO1|-|-|data0|-|

(3) HSPI/PSPI DUAL WRITE

|MOSI_IO0|cmd (write 8bit)|dummy (8clock)|D6|D4|D2|D0|...|
|---|:---:|:---:|---|---|---|---|:---:|
|MISO_IO1|-|-|D7|D5|D3|D1|...|

(4) HSPI/PSPI DUAL READ

|MOSI_IO0|cmd (read 8bit)|dummy (8clock)|D6|D4|D2|D0|...|
|---|:---:|:---:|---|---|---|---|:---:|
|MISO_IO1|-|-|D7|D5|D3|D1|...|

(5) HSPI/PSPI QUAD WRITE

|MOSI_IO0|cmd (write 8bit)|dummy (8clock)|D4|D0|...|
|---|:---:|:---:|---|---|:---:|
|MISO_IO1|-|-|D5|D1|...|
|WP_IO2|-|-|D6|D2|...|
|HOLD_IO3|-|-|D7|D3|...|

(6) HSPI/PSPI QUAD READ

|MOSI_IO0|cmd (read 8bit)|dummy (8clock)|D4|D0|...|
|---|:---:|:---:|---|---|:---:|
|MISO_IO1|-|-|D5|D1|...|
|WP_IO2|-|-|D6|D2|...|
|HOLD_IO3|-|-|D7|D3|...|

**Operation commands supported by HSPI/PSPI Slave**

The operation commands supported by HSPI/PSPI Slave are represented by enumeration definitions in the demo, which correspond to the cmd parameters of the read/write function interface when used.

```C
enum{
    SPI_READ_STATUS_SINGLE_CMD = 0x05,
    SPI_READ_STATUS_DUAL_CMD = 0x15,
    HSPI_READ_STATUS_QUAD_CMD = 0x25,
    SPI_READ_DATA_SINGLE_CMD = 0x0B,
    SPI_READ_DATA_DUAL_CMD = 0x0C,
    HSPI_READ_DATA_QUAD_CMD = 0x0E,
    SPI_WRITE_DATA_SINGLE_CMD = 0x51,
    SPI_WRITE_DATA_DUAL_CMD = 0x52,
    HSPI_WRITE_DATA_QUAD_CMD = 0x54,
};
```

**Note:**

> - The operation commands are related to the HSPI or PSPI mode. The SPI prefix indicates that commands are common for HSPI and PSPI, the HSPI prefix indicates that only HSPI can be used, DUAL_CMD corresponds to Dual SPI mode, and QUAD_CMD corresponds to Quad SPI mode.

### Clock settings

In the SoC, the clock source for the HSPI is hclk and the clock source for the PSPI is pclk.

**Master clock**

The clock calculation formula in Master mode is:

$$F_{Master} = \frac {F_{hclk\&pclk}}{(spi\_clk\_div +1)*2}$$

Where spi_clk_div is the frequency dividing coefficient.

$F_{Master}$ is the CLK frequency of the Master output.

$F_{hclk\&pclk}$ is the frequency of the clock source, where the clock source of HSPI is hclk and PSPI is pclk.

The clock frequency configuration interface of the Master is a macro definition:

```C
#define SPI_CLK   500000
```

The enable interface for clock configuration is:

```C
spi_master_init(SPI_MODULE_SEL, sys_clk.pclk * 1000000 / (2 * SPI_CLK) - 1, SPI_MODE0);
```

For actual use, simply modify the SPI_CLK macro definition to the corresponding clock frequency.

**Note:**

> - When the frequency dividing coefficient is 0xff, the Master output clock frequency can reach the maximum frequency of the source clock.
> - The configuration range of SPI_CLK is described in the demo, which can be referred to when configuring, and exceeding the configuration range may cause communication failure.

**Slave clock**

The clock of the Slave is input by the Master, and the Slave does not need to configure the corresponding clock. However, the clock input by the Master to the Slave needs to satisfy the following conditions:

$$F_{Master} \le \frac {F_{hclk\&pclk}}{3}$$

where $F_{Master}$ is the CLK frequency that the SPI Master inputs to the Slave.

$F_{hclk\&pclk}$ is the Slave device's own internal clock source frequency, PSPI Slave corresponds to pclk frequency, HSPI Slave corresponds to hclk frequency.

### Interrupt

The SoC supports a variety of SPI interrupt types, which can be flexibly configured according to the application scenario when used. The characteristics of each interrupt type are listed in the following table:

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Mode                Related interrupts                              Whether abnormal     Whether manually clear     Generated by Master
                                                                        interrupt        the interrupt flag bit           or Slave
------------------- --------------------------------------------- -------------------- -------------------------- -----------------------
Non-DMA             SPI_RXF_OR_INT: RX FIFO over run interrupt.   Y                    Y                          Slave
                    When receiving data, the program does not
                    read the data fast enough and the RX FIFO
                    will be overwritten with new data, this
                    loss of data is called over run.

Non-DMA             SPI_TXF_UR_INT: TX FIFO under run interrupt.  Y                    Y                          Slave
                    When sending data, the speed at which the
                    program writes data to the TX FIFO cannot
                    keep up with the speed of sending, and
                    there is an interruption in sending data,
                    which is called under run.

Non-DMA             SPI_RXF_INT: RX FIFO threshold (threshold     N                    Y                          Master and Slave
                    value) interrupt. With this interrupt
                    enabled, this interrupt is triggered when
                    the RX FIFO data reaches or exceeds the
                    threshold value.

Non-DMA             SPI_TXF_INT: TX FIFO threshold (threshold     N                    Y                          Master and Slave
                    value) interrupt. With this interrupt
                    enabled, this interrupt is triggered when
                    the TX FIFO data less than or reaches the
                    threshold value.

DMA, not            SPI_END_INT: Data transfer end interrupt,     N                    Y                          Master and Slave
 common             a data transfer completion will trigger
 with               this interrupt.
 DMA

DMA, not            SPI_SLV_CMD_INT: When it is configured to     N                    Y                          Slave
common              Slave mode, this interrupt will be
 with               triggered for every 1Byte command
 DMA                received.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

### DMA mode

Use macro definition to select DMA channels with the following relevant interfaces:

```C
#define TX_DMA_CHN DMA2
#define RX_DMA_CHN DMA3
hspi_set_tx_dma_config(TX_DMA_CHN);
hspi_set_rx_dma_config(RX_DMA_CHN);
```

The example here configures DMA2 for tx channel, configures DMA3 for rx channel. The PSPI is similar, details can be viewed in the demo.

The relevant interfaces used to determine whether data has been sent and received in DMA mode are as follows:

**Enquiry:**

```C
static inline _Bool spi_is_busy(spi_sel_e spi_sel)
```

**Interrupt mode:**

```C
spi_set_irq_mask(SPI_MODULE_SEL, SPI_END_INT_EN);//endint_en
```

**Note:**

> - SPI_END_INT interrupt does not represent the end of data transfer (it just means the end of fifo data transfer, CSN is not pulled up). After generating SPI_END_INT interrupt, query the busy signal, until IDLE represents the end.
> - When using DMA for data transmission, the structure or array that defines the send (receive) is quadruple aligned, as reflected in the demo by \_\_attribute\_\_((aligned(4))).
> - When using DMA to receive SPI data into Buffer, the Buffer size of the corresponding destination address must be a multiple of 4. The reason is: Each DMA sends 4 Bytes to Buffer. 4 Bytes will be written to the destination address even if the configured read length is less than 4. For example, if you define an array Buffer of size 5Byte and configure the DMA to read 5Byte from SPI to Buffer, at this time the DMA actually transfers twice and 8Byte in total to Buffer, and the extra 3Byte data will overflow from the array, and in severe cases the overflowed data will overwrite other variables. In this case, if the array size is configured to 8 Bytes, the extra 3 Bytes will be stored in the array and will not overflow, avoiding the potential risk.

### 3Line

HSPI/PSPI Master/Slave supports 3line mode, which needs to be enabled in Slave.

The interface to be called is:

```C
void spi_set_3line_mode(spi_sel_e spi_sel)
```

**Note:**

> - The 3line mode read/write commands are compatible with SINGLE_CMD of HSPI/PSPI.

### Multi-SPI Slave architecture

For multi-SPI Slave application scenarios, a CSN pin can be assigned to each Slave. When a data transfer is completed, the CSN will be pulled high. At this time, you can switch CSN to achieve the effect of switching Slave.

The HSPI Master calls the interface as follows:

```C
void hspi_cs_pin_dis(hspi_csn_pin_def_e pin)
void hspi_cs_pin_en(hspi_csn_pin_def_e pin)
```

The PSPI Master calling the interface is similar and can be viewed in the code of the interface.

### XIP mode

XIP: eXecute In Place, which means that applications can be command obtained, decoded, and executed directly in the external storage device. The HSPI supports XIP mode, which allows the address space of the SoC to be extended to the external storage device through the HSPI interface, providing a hardware foundation for running applications with large amounts of data.

**Configure XIP mode**

The XIP mode is configured via the following interface.

```C
hspi_xip_seq_mode_en();//must
hspi_xip_page_size(4);
hspi_xip_en();
```

The seq_mode(sequential mode) in the code indicates an interval sending and receiving mode, which means that the data is divided into blocks of $2^{page\_size}$ bytes, and the CS will be pulled up once after each block is transferred, until all the data is completely transferred.

**Sending command**

Send commands through the following interface:

```C
void hspi_master_write_xip_cmd_data(u8 cmd, u32 addr_offset, u8 data_in, spi_wr_tans_mode_e wr_mode)
```

**Data reading and writing**

The read/write data calling interface is as follows:

```C
void hspi_master_write_xip(u8 cmd, u32 addr_offset, u8 *data, u32 data_len, spi_wr_tans_mode_e wr_mode) 
void hspi_master_read_xip(u8 cmd, u32 addr_offset, u8 *data, u32 data_len, spi_rd_tans_mode_e rd_mode)
```

**XIP on-chip running program**

To run the program in XIP mode, you need to switch the PC pointer to the address corresponding to the program in the XIP device before running it. Here the base address of XIP is 0x1000000, switch the PC pointer to the corresponding address of XIP device (base address 0x1000000+relative address 0x00) by the following two commands, and then you can run the program in XIP mode.

```C
__asm__("li t0,0x1000000");
__asm__("jarr t0");
```

## SPI Slave

As the name implies, SPI Slave only supports Slave mode. In the program you only needs to configure the corresponding GPIO of SPI Slave as SPI function. The hardware will automatically parse the received SPI data (read/write the value of the corresponding address) and do the corresponding response. In addition, SPI Slave also supports Dual I/O mode.

### Communication data frame format

The communication data formats supported by the SPI Slave module are listed in the table below.

（1）SPI SLAVE SINGLE WRITE

|MOSI_IO0|cmd (write 8bit)|addr(32bit) high -> low|data0|data1|...|
|:---:|:---:|:---:|:---:|:---:|:---:|
|MISO_IO1|-|-|-|-|-|

（2）SPI SLAVE SINGLE READ

|MOSI_IO0|cmd (read 8bit)|addr(32bit) high -> low|dummy (8cycle)|-|-|
|:---:|:---:|:---:|:---:|:---:|:---:|
|MISO_IO1|-|-|-|data0|-|

（3）SPI SLAVE DUAL WRITE

|MOSI_IO0|cmd (write 8bit)|addr(32bit) high -> low|D6|D4|D2|D0|...|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|MISO_IO1|-|-|D7|D5|D3|D1|...|

（4）SPI SLAVE DUAL READ

|MOSI_IO0|cmd (read 8bit)|addr(32bit) high -> low|dummy (8cycle)|D6|D4|D2|D0|...|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|MISO_IO1|-|-|-|D7|D5|D3|D1|...|

**Note:**

> - "addr(32bit) high -> low" indicates that the high byte comes first in the address order.

### Operation commands supported by SPI Slave

The operation commands supported by SPI Slave are represented by enumeration definitions in the demo, which correspond to the cmd parameters of the read/write function interface when used.

```C
typedef enum{
    SPI_SLAVE_WRITE_DATA_CMD = 0x00,
    SPI_SLAVE_WRITE_DATA_DUAL_CMD,
    SPI_SLAVE_WRITE_ADDR_DUAL_CMD,
    SPI_SLAVE_WRITE_DATA_DUAL_4CYC_CMD,
    SPI_SLAVE_WRITE_ADDR_DUAL_4CYC_CMD,
    SPI_SLAVE_WRITE_DATA_AND_ADDR_DUL_4CYC_CMD,
}spi_slave_write_cmd_e;

typedef enum{
    SPI_SLAVE_READ_DATA_CMD,
    SPI_SLAVE_READ_DATA_DUAL_CMD,
    SPI_SLAVE_READ_ADDR_DUAL_CMD,
    SPI_SLAVE_READ_DATA_DUAL_4CYC_CMD,
    SPI_SLAVE_READ_ADDR_DUAL_4CYC_CMD,
    SPI_SLAVE_READ_DATA_AND_ADDR_DUL_4CYC_CMD,
}spi_slave_read_cmd_e;
```

**Note:**

> - The operation command and the SPI mode are related, DUAL_CMD corresponds to Dual SPI mode, 4CYC_CMD corresponds to dummy 4cycle mode. These commands are or to each other when called. For example, if both address and data support Dual I/O encoding, then the read command format is: SPI_SLAVE__DATA_DUAL_CMD | SPI_SLAVE_READ_ADDR_DUAL_CMD.

# Demo description

## Demo structure description

The application .c files of SPI Demo are app.c, app_dma.c and app_hspi_xip.c, which correspond to DMA, NDMA (non-DMA), and XIP transfer modes, respectively.

Select which transfer mode to use using the macro SPI_MODE in SPI_Demo/app_config. h.

```C
#define SPI_NDMA_MODE   1
#define SPI_DMA_MODE    2
#define SPI_XIP_MODE    3
#define SPI_MODE        SPI_NDMA_MODE
```

In DMA and NDMA transfer modes, the SPI_DEVICE macro in each mode is configured to select Master and Slave modes.

```C
#define SPI_MASTER_DEVICE     1
#define SPI_SLAVE_DEVICE      2
#define SPI_DEVICE            SPI_MASTER_DEVICE
```

Using HSPI or PSPI module is selected via the macro SPI_MODULE_SEL.

```C
#define PSPI_MODULE         0
#define HSPI_MODULE         1
#define SPI_MODULE_SEL      HSPI_MODULE
```

In DMA and NDMA transfer modes, the communication protocols are divided into three categories according to the Slave device, which are selected by the macro SPI_TRANS_MODE.

```C
#define KITE_VULTURE_SLAVE_PROTOCOL      1
#define HSPI_PSPI_SLAVE_PROTOCOL         2
#define SPI_SLAVE_PROTOCOL               3
#define SPI_TRANS_MODE                   SPI_SLAVE_PROTOCOL
```

KITE_VULTURE_SLAVE_PROTOCOL: is a mode designed for use scenarios such as Telink Kite (TLSR825x) or Vulture (TLSR827x) as Slave.

HSPI_PSPI_SLAVE_PROTOCOL: is the mode designed for the use scenario of SoC's HSPI/PSPI as Slave.

SPI_SLAVE_PROTOCOL: it is a mode designed for the use scenario of SPI SLAVE of SoC as Slave.

**Note:**

> - When testing SPI communication of two boards, after burning the code of both the Master end and Slave end to the board, power up the Slave end first and then the Master, and there needs to be a stable common ground between the two boards.

## Hardware connection

The wiring method will be different for different SPI_TRANS_MODE in the Demo.

The hardware connection for KITE_VULTURE_SLAVE_PROTOCOL is as follows:

|HSPI/PSPI Master (SoC)|Slave (Kite/Vulture)|
|--------|:---------|
|CLK|CLK|
|CSN|CSN|
|MOSI_IO0|SDI|
|MISO_IO1|SDO|

The hardware connection for HSPI_PSPI_SLAVE_PROTOCOL is as follows.

|HSPI/PSPI Master (SoC)|HSPI/PSPI Slave (SoC)|
|--------|--------|
|CLK|CLK|
|CSN|CSN|
|MOSI_IO0|MOSI_IO0|
|MISO_IO1|MISO_IO1|
|WP_IO2(HSPI only)|WP_IO2(HSPI only)|
|HOLD_IO3(HSPI only)|HOLD_IO3(HSPI only)|

The hardware connection for SPI_SLAVE_PROTOCOL is as follows.

|HSPI/PSPI Master (SoC)|SPI Slave (SoC)|
|--------|--------|
|CLK|CLK|
|CSN|CSN|
|MOSI_IO0|MOSI_IO0|
|MISO_IO1|MISO_IO1|

## Initial configuration of HSPI/PSPI Master/Slave

The initialization flow of HSPI/PSPI Master/Slave is shown in the following diagram:

![HSPI/PSPI Master/Slave initialization flow](pic/masterslaveinitializationflow.png "HSPI/PSPI Master/Slave initialization flow")

## HSPI/PSPI Master read/write operations

The read/write operation flow of HSPI/PSPI Master is shown in the following diagram:

![HSPI/PSPI Master read/write operation flow](pic/masterreadwriteoperationflow.png "HSPI/PSPI Master read/write operation flow")

### Test example

The Demo configures HSPI in SPI_SLAVE_PROTOCOL mode as Dual SPI, HSPI Master writes 16Bytes data to SPI Slave using DMA via Dual I/O write command SPI_SLAVE_WRITE_DATA_DUAL_CMD | SPI_ SLAVE_WRITE_ADDR_DUAL_CMD, and then reads it out using DMA via Dual I/O read command SPI_READ_DATA_DUAL_CMD | SPI_READ_ADDR_DUAL_CMD. The test is successful and the logic analyzer waveform is as follows:

![Logic analyzer waveform](pic/logicanalyzerwaveform.png "Logic analyzer waveform")

## SPI_XIP_MODE mode

The XIP Device for Demo is a PSRAM model APS1604M-3SQR, which supports both traditional SPI and QUAD SPI modes.

### Communication format

The communication format of PSRAM in Demo is enabled by macro definition, and the macro definition and meaning are as follows:

```C
#define SPI_XIP_SERIAL_CMD_READ                1
#define SPI_XIP_SINGLE_CMD_FAST_READ           2
#define SPI_XIP_SINGLE_CMD_FAST_QUAD_READ      3
#define SPI_XIP_QUAD_CMD_FAST_READ             4
#define SPI_XIP_QUAD_CMD_FAST_QUAD_READ        5
#define SPI_XIP_LOAD_PROGRAM_TO_PSRAM          6

#define SPI_XIP_TEST_MODE        SPI_XIP_SERIAL_CMD_READ
```

SPI_XIP_SERIAL_CMD_READ: Single-line command data read/write mode.

SPI_XIP_SINGLE_CMD_FAST_READ: Upgrade mode for single-line command data read/write, supporting higher CLK.

SPI_XIP_SINGLE_CMD_FAST_QUAD_READ: Single-line command four-line data read/write mode.

SPI_XIP_QUAD_CMD_FAST_READ: Four-line command four-line data read/write mode.

SPI_XIP_QUAD_CMD_FAST_QUAD_READ: Upgrade mode for four-line command four-line data read/write, supporting higher CLK.

SPI_XIP_LOAD_PROGRAM_TO_PSRAM: The mode of running the program inside the chip.

**Note:**

> - The APS1604M-3SQR supports a variety of communication formats, from single-line cmd frame to four-line cmd frame, and the number of dummies varies with the mode difference, all of which are reflected in the demo. Here only represents the meaning of the interfaces called, if users want to know more about the application, they can refer to the demo and the related PSRAM manual when developing.

### Configure XIP mode

The APS1604M-3SQR hardware requires that the single data transfer time should not exceed 8us (some versions are 4us, check the product manual for details), otherwise there will be a risk of error, therefore the seq_mode should be enabled when configuring XIP mode to. The page_size is set to 1 in the figure below, and 8 bytes data (0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x77) are written on the PSRAM base address 0x000000, the data is divided into 4 blocks and sent each time $2^{page\_size}$ = 2bytes, sent in four times to complete. The time interval between adjacent CSN pull-ups is less than 8us.

![Configuring XIP mode](pic/configuringxipmode.png "Configuring XIP mode")

**Note:**

> - Because of the 8us interval required by the APS1604M-3SQR, the CLK frequency has to be increased to reduce the time consumed by each transfer of $2^{page\_size}$ Bytes of data to meet the 8us requirement, so the SPI_CLK of the HSPI in XIP mode is higher than the general SPI application. When the SPI_CLK cannot be adjusted to meet the 8us requirement, the size of page_size can be configured to reduce the number of bytes per transfer and increase the number of transfers to meet the time requirement.

### Test example

The Demo configures HSPI to QUAD XIP mode, writes the LED blinking program in the array led_program_in _sram to PSRAM address 0x00 via HSPI XIP, and then jumps to the corresponding address in PSRAM to execute the program.

The test found that LED2 blinks at intervals, proving that the PSRAM on-chip running program is successful.

Read the program in PSRAM to the array led_program_in_psram, read the array led_program_in_psram and led_program_in_sram by BDT tool to compare, the two sets of data are exactly the same, which proves the success of reading and writing PSRAM.

![Test example](pic/testexample.png "Test example")
